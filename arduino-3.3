// Задание 3: Использование внешнего прерывания для сканирования клавиатуры

// Выводы для клавиатуры 4х4
const int rowPins[4] = {8, 7, 6, 5};     // Строки (Row)
const int colPins[4] = {11, 10, 9, 4};   // Столбцы (Col)
// Матрица символов для каждой клавиши; keys[строка][столбец]
char keys[4][4] = {
  {'1', '2', '3', 'A'},
  {'4', '5', '6', 'B'},
  {'7', '8', '9', 'C'},
  {'*', '0', '#', 'D'}
};

volatile byte currentRow = 0; // Текущая активируемая строка
volatile bool keyDetected = false; // Флаг обнаружения нажатия
volatile char detectedKey = 0; // Какой символ был нажат

// Функция настройки пинов для управления строками и чтения столбцов
void setupKeyboardPins() {
  // Настройка строк как выходы (управляем ими)
  for(int i = 0; i < 4; i++) {
    pinMode(rowPins[i], OUTPUT);
    digitalWrite(rowPins[i], HIGH); // Изначально все строки отключены (HIGH)
  }
  // Настройка столбцов как входы (читаем их)
  for(int i = 0; i < 4; i++) {
    pinMode(colPins[i], INPUT_PULLUP); // используем подтягивающий резистор для надёжного чтения
  }
}

// ISR для сканирования (вызывается Timer0 каждую 1 мс)
ISR(TIMER0_COMPA_vect) {
  // 1. Отключаем предыдущую строку
  digitalWrite(rowPins[currentRow], HIGH);
  // 2. Переходим к следующей строке (циклически)
  currentRow = (currentRow + 1) % 4;
  // 3. Активируем новую строку (LOW)
  digitalWrite(rowPins[currentRow], LOW);
  // 4. Чтение столбцов, если есть нажатие — фиксируем
  for (int col = 0; col < 4; col++) {
    if (digitalRead(colPins[col]) == LOW) { // LOW значит нажатие
      detectedKey = keys[currentRow][col]; // Запоминаем символ
      keyDetected = true; // Поднимаем флаг для основного цикла
    }
  }
}

void setup() {
  Serial.begin(9600);
  setupKeyboardPins(); // Готовим пины для работы с клавиатурой

  // Настройка Timer0 для генерации прерывания каждые 1 мс
  TCCR0A = 0;
  TCCR0B = 0;
  TCCR0A |= (1 << WGM01); // режим CTC
  OCR0A = 249;            // 1 мс для 16 МГц и предделителя 64: (16 000 000 / (64 * 1000)) - 1 = 249
  TIMSK0 |= (1 << OCIE0A);
  TCCR0B |= (1 << CS01) | (1 << CS00); // предделитель 64
  sei(); // Включаем глобальные прерывания
}

void loop() {
  // Если в прерывании был обнаружен нажатый символ
  if (keyDetected) {
    // Выводим нажатую клавишу в монитор порта
    Serial.print("Нажата клавиша: ");
    Serial.println(detectedKey);
    keyDetected = false; // Сбрасываем флаг — готовим к следующему сканированию
  }
}
